 .. Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
 ..   http://www.apache.org/licenses/LICENSE-2.0
 .. Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

.. _application:

Application
===========

ForML applications represent a high-level concept built on top of ForML :ref:`projects <project>`
as deliverables for the :ref:`serving layer <serving>`.

The term *application* in this context doesn't hold the common meaning as a general computer program
covering a wide range of potential functions. ForML applications obviously focus just on ML
inference (providing predictions in response to the presented data points) representing the *apply*
stage of the :ref:`production lifecycle <lifecycle-production>`.

While the purpose of :ref:`projects <project>` is to implement a solution to the given ML problem,
*applications* aim to expose it in a form suitable for integration with the actual decision
making process.

Relationships between projects and applications can have any possible cardinality. Projects might
not be associated with any application (not exposed for serving), on the other hand an
application can possibly span multiple projects (its :meth:`model selection strategy <forml
.project.Descriptor.select>` can involve multiple projects) or a single project might be utilized by
several different applications. It makes sense to manage an application (descriptor) in scope of
some particular project if they constitute a 1:1 relationship (perhaps the most typical scenario).
More complex applications might need to be maintained separately though.


portability?


Request Handling
----------------

Upon accepting a request and routing it to a defined application by the :ref:`serving engine
<serving>`, the given application becomes responsible for:

#. Formally :meth:`receiving <forml.application.Descriptor.receive>` the request by:
   * :ref:`decoding <io-encoding>` the request payload
   * optionally adjusting the data for predicting
   * optionally assembling custom metadata to constitute an application context (scope)
#. :meth:`Selecting <forml.application.Descriptor.select>` a particular model generation based
   the defined strategy.
#. Producing a :meth:`response <forml.application.Descriptor.respond>` (based on the
   predictions generated by the engine using the selected model) which involves:
   * assembling the result content
   * :ref:`encoding <io-encoding>` the response payload


.. autoclass:: forml.project.Descriptor
   :members: name, receive, respond, select


.. autoclass:: forml.application.Generic
   :show-inheritance:




Strategy
--------

.. autoclass:: forml.application.Selector
   :members: select


.. autoclass:: forml.application.Explicit
   :show-inheritance:

.. autoclass:: forml.application.Latest
   :show-inheritance:
