 .. Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
 ..   http://www.apache.org/licenses/LICENSE-2.0
 .. Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

.. _demos:

Pipeline Demos
==============

This chapter presents a number of ForML pipelines demonstrating the :ref:`workflow concept
<workflow>`. These are stripped-down snippets focusing purely on the pipelining without constituting
full-fledged :ref:`ForML projects <project>`.

To visualize the composed workflow DAGs, we are going to execute the pipelines using the
:class:`Graphviz runner <forml.provider.runner.graphviz.Runner>` via the interactive
:class:`runtime.Virtual <forml.runtime.Virtual>` launcher.

.. caution::
    Despite still perfectly executable, all the operators as well as the actual dataset have been
    put together just to illustrate the topological principles without seeking true functional
    suitability in the first place.

.. _demos-common:
.. rubric:: Common Code

Let's start with a common code shared among the individual demos:

#. We define a dummy dataset schema with just three columns - a sequence ID of each record
   (``Ordinal``), the independent data point (``Feature``) and a hypothetical outcome (``Label``).
#. Using this dataset, we load it as inline data into the :class:`Monolite feed
   <forml.provider.feed.monolite.Feed>` that we will be explicitly engaging when launching each
   of the demos.
#. Finally, we define the standard :class:`Source descriptor <forml.project.Source>` by specifying
   the *features* :ref:`DSL query <query>` plus the *label* and *ordinal* columns.

.. note::
    Only the last step (the :class:`Source descriptor <forml.project.Source>` declaration) would
    normally be part of any :ref:`project implementation <project-source>`. All the data
    provisioning (the :ref:`feed setup <feed>`) would be delivered independently via the configured
    :ref:`platform <platform>`.

.. literalinclude:: ../../tutorials/demos/__init__.py
  :caption: tutorials/demos/__init__.py
  :linenos:
  :language: python
  :start-at: import

Mini
----

Starting with a minimal use-case, this *mini*-pipeline contains just a single (:ref:`stateful
<actor-type>`) operator - the :class:`RandomForestClassifier
<sklearn:sklearn.ensemble.RandomForestClassifier>` imported from the SKLearn library under the
:ref:`operator auto-wrapping <operator-autowrap>` context which turns it transparently into a
true :ref:`ForML operator <operator>`.

To launch the pipeline, it is first :meth:`bound <forml.project.Source.bind>` to the :class:`Source
descriptor <forml.project.Source>` (declared previously in the :ref:`common section
<demos-common>`) to dynamically assemble a virtual :class:`Artifact <forml.project.Artifact>` that
directly exposes a :meth:`launcher instance <forml.project.Artifact.launcher>`. We select the
:class:`Graphviz runner <forml.provider.runner.graphviz.Runner>` (called ``visual`` in our
:ref:`setup <tutorial-setup>`) and explicitly provide our shared Demo :ref:`feed <feed>` (since
it is not available within the :ref:`platform <platform>` scope).

Bellow you can see the different task graphs produced for each of the *train* versus *apply*
:ref:`modes <workflow-mode>` (note the *ordinal* lower/upper bounds specified when executing each
of the modes used as data filters with respect to the ``Data.Ordinal`` column). Apart from the
expected ``RandomForestClassifier`` node, the topology contains number of additional tasks:

* :class:`Source <forml.project.Source>` related tasks (defined in our :ref:`common section
  <demos-common>`):

  * the :class:`feed reader <forml.io.Feed.Reader>`
  * the positional label extractor (``Slicer``)
  * the explicitly defined stateless :class:`ToPandas <forml.pipeline.payload.ToPandas>` transformer

* :ref:`system nodes <topology-compiler>` generated by the :ref:`flow compiler
  <topology-compiler>` (``Getter``, ``Loader``, ``Dumper``, ``Comitter``)
* the :ref:`sink <sink>` (``Captor``) injected by the launcher

.. literalinclude:: ../../tutorials/demos/mini.py
  :caption: tutorials/demos/mini.py
  :linenos:
  :language: python
  :start-at: import
  :end-at: LAUNCHER

.. md-tab-set::

    .. md-tab-item:: Train Mode

        .. code-block:: python

            LAUNCHER.train(3, 6)

        .. image:: ../_static/images/demos-mini-train.png
          :target: ../_static/images/demos-mini-train.png

    .. md-tab-item:: Apply Mode

        .. code-block:: python

            LAUNCHER.apply(7)

        .. image:: ../_static/images/demos-mini-apply.png
          :target: ../_static/images/demos-mini-apply.png

Simple
------

The next pipeline is demonstrating a true :ref:`workflow expression <workflow-expression>` of two
(again :ref:`stateful <actor-type>`) operators participating in an :ref:`operator composition
<operator-composition>`:

.. literalinclude:: ../../tutorials/demos/simple.py
  :caption: tutorials/demos/simple.py
  :linenos:
  :language: python
  :start-at: import
  :end-at: LAUNCHER

.. md-tab-set::

    .. md-tab-item:: Train Mode

        .. code-block:: python

            LAUNCHER.train(3, 6)

        .. image:: ../_static/images/demos-simple-train.png
          :target: ../_static/images/demos-simple-train.png

    .. md-tab-item:: Apply Mode

        .. code-block:: python

            LAUNCHER.apply(7)

        .. image:: ../_static/images/demos-simple-apply.png
          :target: ../_static/images/demos-simple-apply.png


Ensemble
--------

The ability to derive fairly involved workflows from simple expressions is demonstrated in the
following pipeline employing the :mod:`model ensembling <forml.pipeline.ensemble>` technique. For
readability, we use just two levels of folding (``n_splits=2``), the graph would be even more
complex with higher folding levels.

.. literalinclude:: ../../tutorials/demos/ensemble.py
  :caption: tutorials/demos/ensemble.py
  :linenos:
  :language: python
  :start-at: import
  :end-at: LAUNCHER

.. md-tab-set::

    .. md-tab-item:: Train Mode

        .. code-block:: python

            LAUNCHER.train(3, 6)

        .. image:: ../_static/images/demos-ensemble-train.png
          :target: ../_static/images/demos-ensemble-train.png

    .. md-tab-item:: Apply Mode

        .. code-block:: python

            LAUNCHER.apply(7)

        .. image:: ../_static/images/demos-ensemble-apply.png
          :target: ../_static/images/demos-ensemble-apply.png


Complex
-------

Going one step further, the following pipeline is again using the model ensembling technique, but
this time it is defines distinct transformation chain for each of the model branches
(``OneHotEncoder`` for the ``RandomForestClassifier`` and ``Binarizer`` for ``BernoulliNB``).

.. literalinclude:: ../../tutorials/demos/complex.py
  :caption: tutorials/demos/complex.py
  :linenos:
  :language: python
  :start-at: import
  :end-at: LAUNCHER

.. md-tab-set::

    .. md-tab-item:: Train Mode

        .. code-block:: python

            LAUNCHER.train(3, 6)

        .. image:: ../_static/images/demos-complex-train.png
          :target: ../_static/images/demos-complex-train.png

    .. md-tab-item:: Apply Mode

        .. code-block:: python

            LAUNCHER.apply(7)

        .. image:: ../_static/images/demos-complex-apply.png
          :target: ../_static/images/demos-complex-apply.png


Custom
------

In this pipeline we demonstrate the ability to define custom :ref:`actors <actor-decorated>` and
:ref:`operators <operator-wrapped>`. We implement a simple :ref:`stateful <actor-type>`
mapper that at :ref:`train-mode <workflow-mode>` persists the *mean* and *standard
deviation* of the observed column and at *apply-mode* generates random integers within the given
``meanÂ±std`` range for any missing value.

.. literalinclude:: ../../tutorials/demos/custom.py
  :caption: tutorials/demos/custom.py
  :linenos:
  :language: python
  :start-at: import
  :end-at: LAUNCHER

.. md-tab-set::

    .. md-tab-item:: Train Mode

        .. code-block:: python

            LAUNCHER.train(3, 6)

        .. image:: ../_static/images/demos-custom-train.png
          :target: ../_static/images/demos-custom-train.png

    .. md-tab-item:: Apply Mode

        .. code-block:: python

            LAUNCHER.apply(7)

        .. image:: ../_static/images/demos-custom-apply.png
          :target: ../_static/images/demos-custom-apply.png
